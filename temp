The issue you're encountering‚Äîgetting the last value as null‚Äîis due to how the LEFT JOIN works in your swapped_pairs CTE. Let me explain and show how to fix it.


---

üîç Problem Breakdown

In your dataset:

id	val

1	Alice
2	Bob
3	Charlie
4	David
5	Eve


You want to swap every pair of adjacent rows, i.e.:

Alice ‚Üî Bob

Charlie ‚Üî David

Eve ‚Üî ???


But Eve has no partner (no even-numbered row after her). Your LEFT JOIN includes her in the swapped_pairs, but val1 (even row value) becomes NULL.

So this results in:

id	val

1	Bob
2	Alice
3	David
4	Charlie
5	NULL



---

‚úÖ Fix

To handle the unpaired last row properly, we need to union in any unmatched rows from the odd_rows that didn‚Äôt get a match.

Here's a revised version of your query:

WITH numbered AS (
  SELECT
    id,
    val,
    ROW_NUMBER() OVER (ORDER BY id) AS rn
  FROM nums
),
odd_rows AS (
  SELECT rn, id, val FROM numbered WHERE MOD(rn, 2) = 1
),
even_rows AS (
  SELECT rn, id, val FROM numbered WHERE MOD(rn, 2) = 0
),
swapped_pairs AS (
  SELECT
    o.id AS id1,
    e.val AS val1,
    e.id AS id2,
    o.val AS val2
  FROM odd_rows o
  LEFT JOIN even_rows e ON o.rn + 1 = e.rn
),
flattened AS (
  SELECT id1 AS id, val1 AS val FROM swapped_pairs WHERE val1 IS NOT NULL
  UNION ALL
  SELECT id2 AS id, val2 AS val FROM swapped_pairs
  UNION ALL
  -- Handle unmatched last odd row (e.g., 'Eve')
  SELECT id1 AS id, val2 AS val FROM swapped_pairs WHERE val1 IS NULL
)
SELECT id, val
FROM flattened
ORDER BY id;


---

‚úÖ Output

With this fix, the output will be:

id	val

1	Bob
2	Alice
3	David
4	Charlie
5	Eve



---

Let me know if you want to generalize this to other column types or more complex pairing!

